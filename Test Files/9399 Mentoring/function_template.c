#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     Shooter,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Right,         tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c";

/*
Code Written for team 9399 - Raven,
by 6699 Tempest programmer, Aaron Cook

Usage
-----

General: This code is inteded to be a tool to easily make new autos and even teleops. As is, it does nothing. Combine the functions below to get something nice,
and add some new code for specific actions

float RPM(tMotor input) - If motor "input" has an encoder, you can check the RPM, be careful of overflowing
	-returns in rotations per second, NOT minute
	-be careful of encoder resets too

void forward(const int distance) - go forward for "distance" encoder ticks

void backward(const int distance) - go back for "distance" encoder ticks

void left(const int distance) - turn left for "distance" encoder ticks

void right(const int distance) - turn right for "distance" encoder ticks

void shoot(const int time) - run the shooter for "time" milliseconds
	-you need to add your ball deployment mechanism to the while loop (most likely)
*/

int mSpeed = 30;
int sSpeed = 100;

float RPM(tMotor input){
	int position1;
	int position2;
	float rpm;

	wait1Msec(100);
	position1 = nMotorEncoder(input);
	wait1Msec(100);
	position2 = nMotorEncoder(input);

	rpm = abs(((float)position2 - (float)position1) * 600 / 1440);//converting from ticks/decisecond to rotations/second

	return rpm;
}

void forward(const int distance){
	nMotorEncoder(Right) = 0;
	nMotorEncoder(Left) = 0;
	wait1Msec(50);

	motor[Right] = mSpeed;
	motor[Left] = mSpeed;

	while(abs(nMotorEncoder(Right)) < distance && abs(nMotorEncoder(Left)) < distance){
	}

	motor[Right] = 0;
	motor[Left] = 0;
}

void backward(const int distance){
	nMotorEncoder(Right) = 0;
	nMotorEncoder(Left) = 0;
	wait1Msec(50);

	motor[Right] = -mSpeed;
	motor[Left] = -mSpeed;

	while(abs(nMotorEncoder(Right)) < distance && abs(nMotorEncoder(Left)) < distance){
	}

	motor[Right] = 0;
	motor[Left] = 0;
}

void left(const int distance){
	nMotorEncoder(Right) = 0;
	nMotorEncoder(Left) = 0;
	wait1Msec(50);

	motor[Right] = mSpeed;
	motor[Left] = -mSpeed;

	while(abs(nMotorEncoder(Right)) < distance && abs(nMotorEncoder(Left)) < distance){
	}

	motor[Right] = 0;
	motor[Left] = 0;
}

void right(const int distance){
	nMotorEncoder(Right) = 0;
	nMotorEncoder(Left) = 0;
	wait1Msec(50);

	motor[Right] = -mSpeed;
	motor[Left] = mSpeed;

	while(abs(nMotorEncoder(Right)) < distance && abs(nMotorEncoder(Left)) < distance){
	}

	motor[Right] = 0;
	motor[Left] = 0;
}

void shoot(const int time){
	//I gave you my RPM function, I don't know how reliable it is on your system, so I'm running your motors at 100% for a certain time, again I don't know how you want to shoot
	motor[Shooter] = sSpeed;
	ClearTimer(T1);

	while(time1(T1) < time){
		//probably some servo stuff in here to release balls, I don't know how that works for you
	}

	motor[Shooter] = 0;
}

task main()
{
//Combine the functions here to make an easily changeable program
}
