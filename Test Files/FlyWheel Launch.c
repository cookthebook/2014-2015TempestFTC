#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     Right1,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right2,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Left1,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Left2,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Launcher,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     Screw,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    BallRelease,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"

#define SeekerL 	msensor_S3_1
#define SeekerR 	msensor_S3_2
#define Gyro			msensor_S3_3

int servoPos1 = 90;
int servoPos2 = 110;

float wheelDiameter = 3;
float wheelCircumference = wheelDiameter*PI;
float gearFactor = 3*3;
//in rps
float wheelSpeed;
float motorSpeed = 50;
//Get from testing
float correctionFactor = 1.1;
float speedThreshold = 5;
float V;



float RPS(tMotor input){
	int position1;
	int position2;
	float rps;

	position1 = nMotorEncoder(input);
	wait1Msec(100);
	position2 = nMotorEncoder(input);

	rps = (position2 - position1) * 10 / 1440;//converting from ticks/decisecond to rotations/second

	return rps;
}

task main()
{
//NOTE: angle is 85 degrees by default
//Refer to calculations in GeoGebra file
V = 175.6;

wheelSpeed = V/wheelCircumference * correctionFactor;

do{
	motor[Launcher] = motorSpeed;
	wait1Msec(250);
	if(RPS(Launcher)*gearFactor > wheelSpeed + speedThreshold) motorSpeed--;
	if(RPS(Launcher)*gearFactor < wheelSpeed - speedThreshold) motorSpeed++;
}while(abs(RPS(Launcher)*gearFactor - wheelSpeed) > speedThreshold);

servo[BallRelease] = servoPos2;
wait1Msec(500);
servo[BallRelease] = servoPos1;
}
