#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     Ultra2,         sensorSONAR)
#pragma config(Motor,  motorA,          Belt1,         tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          Belt2,         tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     Left1,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Right1,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     Launch1,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     Launch2,       tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S2_C1_1,    IR1,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    IR2,                  tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    Deploy,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-gyro.h"
#include "drivers/lego-ultrasound.h"

#define SeekerL 	msensor_S3_1
#define SeekerR 	msensor_S3_2
#define Gyro			msensor_S3_3
#define Ultra1		msensor_S3_4

int mSpeed = 50;
int threshold = 10;
int Dfactor;

int lSpeed = 75;

int servo1Pos = 30;
int servo2Pos = 225;

float minimumRPM = 140.0;
float maximumRPM = 160.0;

void Left(int speed){
	motor[Left1] = speed;
	motor[Left2] = speed;
}

void Right(int speed){
	motor[Right1] = speed;
	motor[Right2] = speed;
}



float RPM(tMotor input){
	int position1;
	int position2;
	float rpm;

	wait1Msec(100);
	position1 = nMotorEncoder(input);
	wait1Msec(100);
	position2 = nMotorEncoder(input);

	rpm = abs(((float)position2 - (float)position1) * 600.0 / 1440.0);//converting from ticks/decisecond to rotations/second

	return rpm;
}



void triangulate(){
bool Triangulating = true;

while(Triangulating){
	if(HTIRS2readDCDir(SeekerL) < 6){
		if(HTIRS2readDCDir(SeekerR) < 4){
			//left
			Right(mSpeed / 2);
			Left(-mSpeed / 2);
		}

		if(HTIRS2readDCDir(SeekerR) > 4){
			//forward
			Right(mSpeed / 2);
			Left(mSpeed / 2);
		}

		if(HTIRS2readDCDir(SeekerR) == 4){
			//left
			Right(mSpeed / 2);
			Left(-mSpeed / 2);
		}
	}


	if(HTIRS2readDCDir(SeekerL) > 6){
		if(HTIRS2readDCDir(SeekerR) < 4){
			//back
			Right(-mSpeed / 2);
			Left(-mSpeed / 2);
		}

		if(HTIRS2readDCDir(SeekerR) > 4){
			//right
			Right(-mSpeed / 2);
			Left(mSpeed / 2);
		}

		if(HTIRS2readDCDir(SeekerR) == 4){
			//right
			Right(-mSpeed / 2);
			Left(mSpeed / 2);
		}
	}

	if(HTIRS2readDCDir(SeekerL) == 6){
		if(HTIRS2readDCDir(SeekerR) < 4){
			//left
			Right(-mSpeed / 2);
			Left(mSpeed / 2);
		}

		if(HTIRS2readDCDir(SeekerR) > 4){
			//right
			Right(-mSpeed / 2);
			Left(mSpeed / 2);
		}

		if(HTIRS2readDCDir(SeekerR) == 4){
			//stop, break
			Right(0);
			Left(0);
			Triangulating = false;
		}
	}
}
}



void launch(int count){
	int Launched = 0;

	if(Launched < count){
		if(HTIRS2readDCDir(SeekerR) == 4 && HTIRS2readDCDir(SeekerL) == 6){
			motor[Launch1] = lSpeed;
			motor[Launch2] = lSpeed;
			wait1Msec(3000);
			ClearTimer(T2);
			do{
				if(RPM(Launch1) < minimumRPM){
					lSpeed += 1;
					motor[Launch1] = lSpeed;
					motor[Launch2] = lSpeed;
				}
				else if(RPM(Launch1) > maximumRPM){
					lSpeed--;
					motor[Launch1] = lSpeed;
					motor[Launch2] = lSpeed;
				}
				else{
					//Deploy
					servo[Deploy] = 0;
					if(time1(T2) > 1500){
						Launched++;
						servo[Deploy] = 127;
					}
				}
			}while(Launched != count);
		}else{
			triangulate();
		}
	}else{
		motor[Launch1] = 0;
		motor[Launch2] = 0;
	}
}


task main()
{
waitForStart();
while(true){
	getJoystickSettings(joystick);
	if(joy1Btn(7)){
		Dfactor = 3;
	}else{
		Dfactor = 1;
	}

	//Drive
	if(abs(joystick.joy1_y1) > threshold){
		Left(mSpeed*(abs(joystick.joy1_y1)/joystick.joy1_y1) / Dfactor);
	}else{
		Left(0);
	}

	if(abs(joystick.joy1_y2) > threshold){
		Right(mSpeed*(abs(joystick.joy1_y2)/joystick.joy1_y2) / Dfactor);
	}else{
		Right(0);
	}

	//Launcher
	//End game, launch all 5
	ClearTimer(T1);
	while(joy1Btn(5) && joy1Btn(6)){
		if(time1(T1) >= 1000) launch(5);
	}

	//Collecting Belt (eventually with joy2)
	if(joystick.joy1_TopHat == 0){
		motor[Belt1] = 100;
		motor[Belt2] = 100;
	}
	else if(joystick.joy1_TopHat == 4){
		motor[Belt1] = -100;
		motor[Belt2] = -100;
	}
	else{
		motor[Belt1] = 0;
		motor[Belt2] = 0;
	}

	//Keep servo in place//
	servo[IR1] = servo1Pos;
	servo[IR2] = servo2Pos;

	wait1Msec(50);
}
}
