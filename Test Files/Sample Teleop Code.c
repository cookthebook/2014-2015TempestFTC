#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          Sweep,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    MyServo,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
This code is loosely based upon the possible setup of your robot
It is not meant to be actually run with your robot, merely an example of how one might be setup
I would suggest using this as a guide but writing your own code from scratch, don't copy/paste
*/

//This is to have the correct functions available for use
#include "JoystickDriver.c"

//Global Vars
//Joystick threshold to initiate drive movement
int threshold = 10;
//A default speed for button enabled DC and Lego motors, I wouldn't surpass 80 for DC, go as high as you want for Lego
int mSpeed = 50;
//Preset positions for a servo
int pos1 = 70;
int pos2 = 100;
int def = 85;



task main()
{
//This is required at the very beginning of all programs, teleop and autonomous
//It waits for a starting signal either from your usb/bluetooth/wifi connected computer
//or from the Field Control System (FCS) during tournaments
//Without it you will not pass inspection
waitForStart();

//The continuous loop is common in all teleops to keep you running, the FCS will terminate the program for you
while(true){
	//Example Tank drive system
	//Left side
	if(abs(joystick.joy1_y1) > threshold){
		//The (float) makes sure you don't get weird integer division behavior
		motor[Left] = ((float)joystick.joy1_y1*100.0) / 148.0;
		//OR motor[Left] = joystick.joy1_y1;
	}else{
		motor[Left] = 0;
	}

	//Right side
	if(abs(joystick.joy1_y2) > threshold){
		motor[Right] = ((float)joystick.joy1_y2*100.0) / 148.0;
		//OR motor[Right] = joystick.joy1_y2;
	}else{
		motor[Right] = 0;
	}

	//Alternative
	motor[Left] = abs(joystick.joy1_y1) > threshold ? ((float)joystick.joy1_y1*100.0) / 148.0 : 0;
	motor[Right] = abs(joystick.joy1_y1) > threshold ? ((float)joystick.joy1_y2*100.0) / 148.0 : 0;



	//Button enabled motor
	//The four btns on the right are [1,4], and back right is 6 and 8, back left is 5 and 7
	//If btn 6 is pressed and btn 8 is not pressed
	if(joy1Btn(6) && !joy1Btn(8)){
		motor[Sweep] = mSpeed;
	}
	//btn 6 is not pressed and btn 8 is pressed
	else if(!joy1Btn(6) && joy1Btn(8)){
		motor[Sweep] = -mSpeed;
	}
	//anything else, so both are pressed or both are not pressed
	else{
		motor[Sweep] = 0;
	}



	//D-Pad enabled servo
	//TopHat refers to the dpad, released is -1, then starting from the top goes [0,7] clockwise
	//first position, if you press up
	if(joystick.joy1_TopHat == 0){
		servo[MyServo] = pos1;
	}
	//second position, if you press down
	else if(joystick.joy1_TopHat == 4){
		servo[MyServo] = pos2;
	}
	//if you want a default position, if any other value besides up and down (including released)
	else{
		servo[MyServo] = def;
	}
}
}
